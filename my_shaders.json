{
  "0": "// learning tutorials \n\n\n#define VRN_BALL 4.5\n\nvec2 N23(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 18.5453);\n}\n\nvec2 voronoi(in vec2 st)\n{\n    vec2 id = floor(st);\n    vec2 gv = fract(st);\n    vec3 mx = vec3(8.0);\n    vec2 p = vec2(0.);\n\n    for(int y =- 1; y <= 1; y ++ )\n    for(int x =- 1; x <= 1; x ++ )\n    {\n        vec2 offset = vec2(float(x), float(y));\n        vec2 p = N23(id + offset);\n        vec2 r = offset - gv ;\n        r += (.5 + .5 * sin(iTime*5. + 6.2831 * p));\n        float d = dot(r, r);\n\n        if (d < mx.x)\n        mx = vec3(d, p);\n\n    }\n\n    // balls molecules?\n    return vec2(sqrt(mx.x)*VRN_BALL, length(mx.yz)); //balls\n    \n    // germs?\n    //return vec2(sqrt(mx.x)*VRN_BALL, length(p)); // germs\n    \n    // sun hydrogen fusion-fission?\n    //return vec2(sqrt(mx.x)*VRN_BALL, log(1. + .1*dot(mx.xz,mx.xz)));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    // just zoomng/scaling the uv\n    vec2 st = (4.5 + 2.0 * sin(0.2 * iTime)) * uv ;\n\n    vec2 c = voronoi(st);\n\n    float d = c.x ;\n    float cel_id = c.y;\n\n    col = 0.5 + 0.5 * cos(cel_id * 6.2831 + vec3(0.0, 1.0, 2.0));\n    col *= clamp(1.0 - 0.2 * d * d, 0.0, 1.0);\n\n    fragColor = vec4(col, 1.0);\n}",
  "1": "// learning tutorial 2\n// thanx iq & bigWigns and others!\n// minimal temple and lightings\n\n#define ITR 50\n#define EPSILON 0.001\n#define MAX_DIST 50.0\n#define SURF_DIST 0.01\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n//-----------------------------------------------------------------------------\nvec3 sun, sun_col;\n\nvec3 normal;\n\n//------------------------------------------------------\n\nvec2 opRepLim(in vec2 p, in float s, in vec2 lima, in vec2 limb)\n{\n    return p - s*clamp(round(p / s), lima, limb);\n}\n\n\nmat3 RX(float a) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(a), - sin(a),\n        0.0, sin(a), cos(a)\n    );\n}\n\nmat3 RY(float a) {\n    return mat3(\n        cos(a), 0.0, sin(a),\n        0.0, 1.0, 0.0,\n        - sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 RZ(float a) {\n    return mat3(\n        cos(a), - sin(a), 0.0,\n        sin(a), cos(a), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n\n\nfloat smax(float a , float b, float k) {\n\n    float h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    float s = mix(a, b, h) + h*(1.0 - h) * k*0.5 ;\n    return s;\n\n}\n\n//-----------------------------------------------------------------------------\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) + h;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat cyl(vec3 p, float r) {\n    vec3 q = p;\n\n    r -= 0.05 * q.y;\n    r -= 0.05 * pow((0.5 + 0.5 * sin(12.0 * atan(q.x, q.z))), 2.0);\n    r -= 0.1 * pow((0.5 + 0.5 * sin(2.5 * sin(3.5 * q.y))), 0.15) - 0.1;\n\n    float d = length(q.xz) - r ;\n    d = max(d, abs(q.y - .1) - 4. );\n    //d = max(d, -q.y );\n    d *= 0.7;\n    return d;\n\n}\n\n//---------------------------------------------------------------------------------\nfloat scene(vec3 p) {\n    vec3 q = p - vec3(-10.0, 1.0, -4.);\n    vec3 s = vec3(q);\n    //q.xz = mod(q.xz + 1.0 , 2.0) - 1.0;\n\n    q.xz = opRepLim(q.xz, 2.0, vec2(1.0, 1.0), vec2(8.0, 4.0));\n    vec3 qq = vec3(q.x, abs(q.y - 2.0) - 2.0, q.z);\n    float d = plane(p, vec3(0.0, 1.0, 0.0), 0.1);\n    d = min(d, cyl(q, 0.4));\n    d = min(d, box(qq, vec3(0.6, 0.1, 0.6)));\n    d = max(d, - box(s - vec3(9.0, 0.0, 5.0), vec3(6.0, 4.0, 2.0)));\n\n    vec3 f = s - vec3(0.0, - 0.1, 0.0);\n    f.y = abs(f.y- 2.)-2.2;\n    vec3 sz = vec3(0.95, 0.01, 0.95);\n    f.xz = opRepLim(f.xz, 2., vec2(1.0, 1.0), vec2(8, 4.0));\n    d = min(d, box(f, sz - 0.1) - 0.2);\n\n    vec3 g = s - vec3(-3.0, - 0.6, - 3.0);\n    vec3 gsz = vec3(1.5, 0.2, 1.5);\n    g.xz = opRepLim(g.xz, 3.0, vec2(1.0, 1.0), vec2(7.0, 4.0));\n    d = min(d, box(g, gsz - 0.2) - 0.2);\n\n    return d ;\n}\n\n//-----------------------------------------------------------------------------\n\nvec3 raydir(vec2 uv, vec3 ro, vec3 lookat, float zoom) {\n    vec3 forward = normalize(lookat - ro);\n    vec3 temp = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = normalize(cross(forward, temp));\n    vec3 right = cross(up, forward);\n    vec3 screen_center = ro + forward * zoom;\n    vec3 i = screen_center + uv.x * right + uv.y * up;\n    vec3 rd = i-ro;\n    return rd;\n\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < ITR && t < MAX_DIST; ++i)\n    {\n        float dS = scene(ro + t*rd);\n        if (abs(dS) < SURF_DIST )break;\n        t += dS;\n    }\n        return  t ;\n    }\n\n\nvec3 grad(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    return (vec3(scene(p + e.xyy), scene(p + e.yxy), scene(p + e.yyx)) - scene(p)) / e.x;\n}\n\n//------------------------------------------------\n\n\n\n\nvoid luminance(inout vec3 col, float lum)\n{\n\tlum /= \tdot(col.rgb,vec3(0.2126 , 0.7152  ,0.0722) );\n\tcol *= lum;\n}\n\n\nfloat shadow(vec3 ro, vec3 rd, vec3 l_pos)\n{\n    float res = 1.;\n    float d = march(ro+100.*normal*SURF_DIST, rd);\n    vec3 p = ro + d*rd;\n    float dl = length(l_pos - p );\n    if (d < dl)\n        res = 0.;\n    float r = 10.;\n \tres = clamp((res*d*(d - dl)/(d + dl) + r) / (2. * r), 0., 1.);\n\tres = smoothstep(0., .8, res);\n\n    return res;\n}\n\n\nvec3 light(vec3 p, vec3 l_pos, vec3 color, bool nrf) {\n    vec3 ptol = l_pos - p;\n    vec3 ptol_n = normalize(ptol);\n    float d = length(ptol);\n    float difuse = max(dot(ptol_n, normal), 0.1);\n    vec3 difuse_col = pow(difuse/(d*d) , .5) * color;\n    float shadow = shadow(p, ptol_n, l_pos);\n    vec3 col = difuse_col  ;\n    if (nrf) col *= shadow;\n\n\n    return   col;\n\n\n\n}\n\n\nvec3 reflection(vec3 p, vec3 rd ) {\n\n    vec3 reflectDir = normalize(reflect(rd, normal));\n    vec3 o = p + reflectDir * SURF_DIST *10.;\n    float t = march( o , reflectDir);\n    vec3 pt = o + t*reflectDir;\n    vec3 reflected = light(pt,sun, vec3(1.,.0,.0),false ) ;\n\n    return reflected;\n\n}\n\n\n\nvec3 render(vec3 ro , vec3 rd) {\n\n    float t = march( ro , rd);\n    vec3 p = ro + t*rd;\n    normal = normalize(grad(p));\n    luminance(sun_col,3.);\n    vec3 specul = light(p, sun, sun_col,true);\n    specul += light(p, sun-vec3(1.,3.,-2.), sun_col*.5,true);\n    vec3 reflected = reflection(p,rd);\n\n    vec3 col = vec3(.0);\n    float spec = pow( max( normal.y, normal.z ), 2.);\n    col = mix((reflected), vec3(specul), .6 ) + spec*.3 ;\n    col += mix(col ,reflected, .8 );\n\n    return col ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n\n   sun = vec3(5., 8. + m.y + sin(iTime * 0.3 * TWO_PI ) * 3.0, 5.0);\n   sun_col = vec3(1.0, .6, 0.2) * 10.0;\n\n    vec3 col = vec3(0);\n    float t = iTime;\n    float ang = sin(0.2 * t*PI + TWO_PI*m.x) * .5;\n    vec3 camR = vec3( sin(ang + m.x), 0. , cos(ang+ m.y));\n    vec3 ro = vec3(-10.0, 10.0, 15.0) + camR;\n    ro *= RX(-m.x*PI/4. + 0.4);\n    ro *= RY(- m.y * 6.2831);\n    vec3 lookat = vec3(0.0);\n    float zoom = 1.;\n    vec3 rd = raydir(uv, ro, lookat, zoom);\n\n    col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545)); // gamma correction\n    fragColor = vec4(col, 1.0);\n}\n\n",
  "2": "// learning turotial 3 shadows and light in 2D !\n\n// 2d shadow based on https://www.shadertoy.com/view/XdjGDm by @DiLemming\n// same structure but different functions implementation.\n\n// click to move the circle\n\n#define STEPS 10.\n#define  PI 3.1415926;\n#define SCALE 1000.\n\n\nstruct ray {\n\tvec2 o;\n\tvec2 d;\n\tvec2 t;\n};\n\nmat2 R2(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c,  -s, s, c);\n\n}\n\n\n\nfloat square(vec2 p, vec2 pos, float sz) {\n\tvec2 q = p - pos ;\n    q = R2(iTime)*q;\n    float f = max(q.x*q.x , q.y*q.y ) / sz;\n    return f;\n}\nfloat circle(vec2 p, vec2 pos, float sz) {\n    vec2 q = p - pos ;\n    return dot (q, q)  / sz ;\n}\n\n\nfloat scene (in vec2 p) {\n\n    vec2 m = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 cpos = m.xy ;\n    float teta = atan(m.y,m.x );\n    vec2 spos = vec2 (.3*sin(.7*iTime)+.1,.2*cos(.3*iTime)+.2) ;\n    spos = R2(.9*iTime+ .3)*spos;\n    float c = circle(p,cpos,3.+ 1.*cos(teta*30.+ iTime));\n    float f = square(p, spos, 2.);\n\tf = min (f, c ) * SCALE;\n\treturn exp(-.5*f)/(f + 1.);\n}\n\nray make_ray (in vec2 origin, in vec2 target) {\n\tray r;\n\n\tr.o = origin;\n\tr.d = (target - origin) / STEPS;\n\tr.t = target;\n\n\treturn r;\n}\n\nvoid march (inout ray r) {\n    for (float i = 0.; i < 1.; i += .5/STEPS) {\n        float f = scene (r.o);\n        f = .2* pow((1. + f*f), -10.) ;\n        r.o += f * r.d;\n    }\n    r.o -= r.t ;\n\n}\n\nvec3 light (in ray r, in vec3 color) {\n    float d = dot (r.o, r.o);\n\t//vec3 col =   color / (5.5* d + 1.5*color);\n\tvec3 col =   .1*color*exp(2./(1.5*d + 3.*color));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n\tray r0 = make_ray (uv, vec2 (.7, .8));\n    march(r0);\n    vec3 sun = light (r0, vec3 (0.6, 0.2, 0.1) );\n\t//ray r1 = make_ray (uv, vec2 (-1., 1.));\n    //march(r1);\n    //sun += light (r1, vec3 (0.3, 0.2, 0.6) );\n    col += sun;\n\tfloat f = clamp( 1000.*scene(uv)-500.,1.,10.)  ;\n    col.r *= f;\n    col = pow(col, vec3(0.4545)); // gamma correction\n\tfragColor = vec4 (col,1.);\n}\n",
  "3": "// Learning tutorial 4! \n// first attempt to make simple Clouds based on https://www.shadertoy.com/view/wsjfRD\n// by @42yeah,  with no textures LoD and personalized marching and \n// stripped down perlin needed to 2 ! and faster :)\n\n\n#define ITR 30.\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nconst vec3 a1 = vec3(0. );\nconst vec3 b1 = vec3(1.0, 0.0, 0.0);\nconst vec3 c1 = vec3(0.0, 1.0, 0.0);\nconst vec3 d1 = vec3(1.0, 1.0, 0.0);\nconst vec3 e1 = vec3(0.0, 0.0, 1.0);\nconst vec3 f1 = vec3(1.0, 0.0, 1.0);\nconst vec3 g1 = vec3(0.0, 1.0, 1.0);\nconst vec3 h1 = vec3(1.0, 1.0, 1.0);\n\n\nmat3 RX(float a) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(a), - sin(a),\n        0.0, sin(a), cos(a)\n    );\n}\n\nmat3 RY(float a) {\n    return mat3(\n        cos(a), 0.0, sin(a),\n        0.0, 1.0, 0.0,\n        - sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 RZ(float a) {\n    return mat3(\n        cos(a), - sin(a), 0.0,\n        sin(a), cos(a), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n\n};\n\n\nray raydir(vec2 uv, vec2 m) {\n\n    float ang = sin(TWO_PI*m.x) * 1.;\n    vec3 camR = vec3( sin(ang + m.x), 0. , cos(ang+ m.y));\n    vec3 ro = vec3(15.0, 5.0, 15.0) + camR;\n    ro.z -= iTime * .01;\n\n    ro *= RX(-m.x*TWO_PI + iTime*.001 );\n    ro *= RY(- m.y *TWO_PI + iTime*.001);\n    ro *= RZ(- iTime *.01 );\n    vec3 lookat = vec3(0.);\n    float zoom = 1.;\n\n    vec3 forward = normalize(lookat - ro);\n    vec3 temp = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = normalize(cross(forward, temp));\n    vec3 right = cross(up, forward);\n    vec3 screen_center = ro + forward * zoom;\n    vec3 i = screen_center + uv.x * right + uv.y * up;\n    vec3 rd = i-ro;\n\n    ray r ;\n    r.o = ro;\n    r.d = rd;\n    return r;\n\n}\n\nfloat rand(vec3 p) {\n    vec3 q = vec3(12.345, 67.89, 412.12);\n    return fract(sin(dot(p, q )) * 42123.45) *2.0 - 1.;\n}\n\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n\n    float a = rand(u + a1);\n    float b = rand(u + b1);\n    float c = rand(u + c1);\n    float d = rand(u + d1);\n    float e = rand(u + e1);\n    float f = rand(u + f1);\n    float g = rand(u + g1);\n    float h = rand(u + h1);\n\n    float r = mix(mix(mix(a, b, s.x),\n    mix(c, d, s.x), s.y),\n    mix(mix(e, f, s.x),\n    mix(g, h, s.x), s.y), s.z);\n    return smoothstep(.0,1.,pow(r,.5));\n}\n\n\n\nfloat fbm(vec3 p) {\n    vec3 off = vec3(10., 50., .1);\n    off.z *= iTime;\n    vec3 q = p - off;\n    float f = .0;\n    f += 0.5 * perlin(q); q *= 2.0;\n    f += 0.25 * perlin(q); q *= 2.0;\n     return  smoothstep(0., .8, f );\n}\n\nfloat scene( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.,1.0)*iTime*.4;\n    float f = fbm(q);\n    return f;\n}\n\n\nvec4 march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float denseD = 10.;\n    float denseE = 1.;\n    vec4 col = vec4(0.0);\n    for (float i = 0.; i < 1.; i+=1./ITR) {\n        vec3 p = ro + t * rd;\n        float d = scene(p);\n        vec4 color = vec4(d);\n        color *= pow(d/(denseD + d),denseE);\n        col += color * (1. - col.a);\n        t += i*.5;\n    }\n    col.rgb = clamp(col.rgb, 0., 1.) ;\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    ray r = raydir(uv,m);\n    vec3 sky = 2.*mix(vec3(.1, .5, .9), vec3(.1, .1, .9), uv.y);\n    vec4 col = march(r.o, r.d);\n    float fog = .5 - .5*col.a , a = 1.2, b=-.01;\n    vec3 colr = col.rgb;\n    colr = mix(vec3(col.rgb) * a * exp(b*col.a*col.a),sky, fog);\n    fragColor = vec4(colr, 1.0);\n}\n",
  "4": "// Learning tutorial 5! \n// clouds part 2\n//\u00a0based on https://www.shadertoy.com/view/wsjfRD by @42yeah,\n// and https://www.shadertoy.com/view/tt2cWh by @shikz86\n\n#define ITR 30.\n#define EPSILON 0.001\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nvec3 sun, sun_col;\nvec3 normal;\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n};\n\nfloat N21( vec3 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat N11(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat N31(in vec3 n)\n{\n\tvec3 i = floor(n);\n    vec3 f = fract(n);\n    f = f*f*(3.-2.*f);\n    float q = i.x+i.y*57.+i.z*113.;\n    float r =\n    mix(\n        mix(\n            mix(N11(q+0.),N11(q+1.),f.x),\n            mix(N11(q+57.),N11(q+58.),f.x),\n            f.y),\n        mix(\n            mix(N11(q+113.),N11(q+114.),f.x),\n            mix(N11(q+170.),N11(q+171.),f.x),\n            f.y),\n        f.z);\n\n    return r;\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f = 0.5*N31(p);\n    return f;\n}\n\n\nfloat sphere( vec3 q,float r){\n\n    vec3 p = q *.5;\n    p *= 1. - .3*vec3(.1,0.2,.1);\n    p.z *= .6;\n    p.y -= pow(abs(p.x)/15.,-p.y*.1+1.5)*1.2;\n    p.x *= .8;\n    float d = length(p) - r;\n    return d;\n}\n\n\nfloat scene(in vec3 q)\n{\n    vec3 p = q - vec3(0.0,0.,2.0)*sin(iTime*.5);\n    float f = fbm(p);\n    vec2 r = vec2(6.,2.);\n    float d =1.;\n    d -= sphere(p,1.7);\n    d += 1.2*f;\n    return clamp(d,0.,.6);\n}\n\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nray raydir(vec2 uv) {\n\n    vec2 m = iMouse.xy / iResolution.xy;\n    float zoom = 1., roll=0.;\n    float camY = 4.+ .25*sin(iTime*.33) ;\n    float camX = 15. +.25*cos(iTime*.33);\n    float camZ = zoom - 8. ;\n    vec3 camPos = vec3(camX,camY,camZ);\n\n    //camPos += vec3(2., .0 ,2. );\n    vec3 lookat = vec3(0.);\n    ray r ;\n    r.o = camPos;\n    r.t = lookat;\n\n    mat3 viewCam = camera(r, roll);\n    vec3 o = vec3(uv,zoom);\n    vec3 rd =  viewCam * normalize(o);\n    r.d = normalize(rd);\n    return r;\n\n}\n\n\nvoid luminance(inout vec3 col, float lum)\n{\n\tlum /= \tdot(col.rgb,vec3(0.2126 , 0.7152  ,0.0722) );\n\tcol *= lum;\n}\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\nvec3 draw_light(vec3 p, vec3 l, vec3 color, float range, float radius,float shad)\n{\n\tfloat ld = length(p - l);\n\tvec3 rd = normalize(l - p);\n\tif (ld > range) return vec3(0.);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = fillMask(sphere(p - l, radius));\n\treturn (shad* fall + source) * color;\n}\n\n\n\nvec4 march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    // float denseD1 = .5;\n    // float denseE1 = .01;\n    float denseD2 = .01;\n    float denseE2 = .2 ;\n    float dd = 0.;\n    vec4 col = vec4(0.0);\n    for (float i = 0.; i < 1.; i+=1./ITR) {\n        float res = 0.;\n        vec3 p = ro + t * rd;\n        float d = scene(p);\n        vec4 color = vec4(d);\n        luminance(sun_col,1.5);\n        float dl = length(sun - p );\n        if (d < dl)\n            res = .5;\n        vec3 s = draw_light(p,sun,sun_col,100.,8.,.4);\n        color.rgb *= mix(s,color.rgb,.4);\n        //color *= pow(d/(denseD1 + d),denseE1);\n        color *= 1.2*exp(-(d -denseD2)*(d -denseD2)/denseE2);\n        col += color * (1. - col.a);\n        t += i;\n    }\n\n\n\n    col.rgb = clamp(col.rgb, 0., 1.) ;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 uv = st*2.;\n\n    ray r = raydir(uv);\n    vec3 sky = mix(vec3(.1, .6, .9), vec3(.2, .2, .6), (.25-st.y));\n    sun = vec3(5.+.5*sin(iTime*.33)*10. , 15.  , 5.0 +.5*cos(iTime*.33)*10.  );\n    sun_col = vec3(.9, .3, 0.2) ;\n\n    vec4 col = march(r.o, r.d);\n    float fog = 1.1 - .8*col.a , a = 1.5, b = -.001;\n    vec3 colr = col.rgb;\n    colr = mix(vec3(col.rgb) * a * exp(b*col.a*col.a),sky, fog);\n    //gamma correction\n    colr = pow(colr,vec3(1./2.2));\n\n\n\n    fragColor = vec4(colr, 1.0);\n}\n",
  "5": "// Learning tutorial 6!\n// learning about reflections , refractions , lights and terrains\n// terrain based on https://www.shadertoy.com/view/wtfyzf by @yonatan\n// added water :) and tried to make it fast as possible!\n// reflection/refraction based on https://www.shadertoy.com/view/3llXW7 by @eseris\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 100.\n#define SURF 1e-5\n#define FAR 100.\n#define REFSTEP 4.\n#define ZERO min(iFrame,0)\n#define THEIGHT .7\n#define TWIDTH 1.1\n\n\n\n#define pow(a,b) pow(abs(a),(b))\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\nstruct obj\n{\n\n    float d;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n\n};\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.5;\n    r.o = vec3(0., 6., -10.);\n    r.t = vec3(.0);\n\n    float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r ;\n\n}\n\nfloat wave(vec2 xz, float k, float c, float t)\n{\n    float X = xz.x + xz.y - c * t;\n    //return pow(sin(k * X) * exp(-.01*X*X),2.);\n    return pow(sin(k * X) ,2.);\n}\n\nfloat terrain(vec3 p) {\n  float h=0., amp =.8, n;\n  for(float i = 0.; i < 1.; i+=1./3.) {\n    n = sin(p.x) * cos(p.z) ;\n    n = n * n *n -.1*n;\n    h += n * amp;\n    p.xz *= R2(i*i-.5*p.y) ;\n    p.xz *= 3.;\n    amp *= .13;\n    if (p.y - h < -.15){\n        p.xz += iTime*h;\n      p.y += clamp(h * wave(mod(p.xz*2.,4.)+.2,.2,.01,iTime),.0,.2);\n    }\n\n  }\n  return p.y - h;\n}\n\n\n\n\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat bassin(vec3 p) {\n    vec3 p1 = p  - vec3(0, 3., 0);\n    float db2 = box(p1, vec3(3.1, 3., 3.1))-.2;\n    float dp2 = plane(p1,vec4(0, 1., 0,1.));\n    db2 = abs(db2);\n    db2 = max(dp2,db2) ;\n    return db2;\n\n}\n\nobj scene(vec3 p) {\n\n    // float ds = sphere(p-spos, .4);\n    vec3 q = (p-vec3(.0,.2,.0)) * TWIDTH ;\n    float dt = terrain(q);\n    float dp = box(q, vec3(3, .1, 3));\n    dp -= THEIGHT*max(dt,dp);\n    vec3 tcol = vec3(.5,.3,4.)*(q.y+.01*dt);\n    float db2 = bassin(p);\n    obj pln = obj(dp ,tcol,vec3(0.), .6, 1., 3., 100.,1., 1.);\n    //obj sp = obj(ds ,vec3(1.,0.,1.),vec3(0.),  .25, 1., 3., 100.,1.,2.);\n    obj bx2 = obj(db2 ,vec3(0.,1.,1.),vec3(0.),  .25, 1., 3., 100.,.2, 3.);\n\n    obj r = uop(pln,bx2);\n\n    return r;\n}\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(0, iFrame); i<3; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += (s.d);\n    }\n\n    s.d = t;\n    return s;\n}\n\n\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += (dif + spec + ambi) ;\n\n\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\nvec3 draw_star(vec3 p, star s, vec3 rd, float d, float i)\n{\n    float g = .0;\n    vec3 lp = s.pos - p;\n    float l = dot(lp,lp);\n    if ( l  - s.rad < d *10.)\n    {\n        float a = max(abs(dot(normalize(lp), rd)), 0.1);\n\t\tg = pow(a,3000.);\n    }\n\n    return s.col * g * i;\n}\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(1.5*theta), 1.5 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.1,.1,.8), 1. );\n\n    for(float i = 0.; i < 1.; i += 1./REFSTEP) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n        vec3 s = draw_star(p,blue,r.d,ob.d,20.);\n        resCol += s ;\n\n        ob.col *= pow(smoothstep(FAR, 20., 2.*ob.d), 20.);\n        if(ob.id < 3. ) {\n            resCol += ob.col * alpha  ;\n       \t\talpha *= 0.1;\n            r.d = reflect(r.d, normal);\n        }\n        else {\n            resCol += ob.col * alpha *ob.transparency;\n            alpha *= (1. - ob.transparency);\n            r.d = refract2(r.d, normal,1.03);\n        }\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n\n    }\n\n\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy ;\n\n    ray r = raydir(uv,m);\n\n    vec3 color = render(r);\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n}",
  "6": "//lerning tutorial 7\n// collision with persistant state.\n// problem with rotation after impact didnt wanna work!?\n\n// rabbit was made by fizzer https://www.shadertoy.com/view/XlccWH\n\nobj_geo get_obj(int i) {\n    vec4 c = texelFetch(iChannel0, ivec2(i,C), 0);\n    vec4 oc = texelFetch(iChannel0, ivec2(i,OC), 0);\n    return   obj_geo(c.xyz, oc.xyz,  vec3(0.),  vec3(.25,.1,FAR),\n                    vec3(.0),vec3(.0),vec3(.5));\n}\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    r.zoom = 1.;\n    r.o = vec3(0., 6., -10.);\n    r.t = vec3(.5);\n\n    // float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\nvoid update() {\n\n    for(int i = 0; i < N; i++) {\n        obj_geo geo = get_obj(i);\n        obs[i].geo.c = geo.c;\n        obs[i].geo.oc = geo.oc;\n\n    }\n}\n\nvoid spheres(vec3 p ) {\n\n    float ds1 = sphere(p,obs[0].geo.c , .3);\n    //float ds1 = rabbit(p,obs[0].geo.c, vec3(1.));\n    //float ds2 = abox(p,obs[1].geo.c, vec3(.35));\n    float ds2 = rabbit(p,obs[1].geo.c, vec3(.5) , iResolution.x,iTime);\n    obs[0].d = ds1;\n    obs[1].d = ds2;\n\n}\n\nobj scene(vec3 p) {\n\n    float dp = box(p, vec3(3, .1, 3)) ;\n    float db2 = bassin(p);\n\n    spheres(p);\n    obj_geo sp1_geo= obj_geo(vec3(0., 1.  , 0.),vec3(0.),vec3(0.),vec3(1.,.5,FAR),vec3(.0),vec3(.0,.0,.0) ,vec3(.4));\n    obj pln = obj(dp ,vec3(.1,.5,.2),vec3(0.), .5, 1., 3., 100.,1., 1.,sp1_geo);\n    obj bx2 = obj(db2,vec3(0.,1.,1.),vec3(0.),  .5, 1., 3., 100.,.1, 2.,sp1_geo);\n    obj sp1 = obs[0];\n    obj sp2 = obs[1];\n\n    obj r = uop(pln,bx2);\n    r = uop(r,sp1);\n    r = uop(r,sp2);\n\n    return r;\n}\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += s.d;\n    }\n\n    s.d = t;\n    s.geo.m_mi.z = t;\n    return s;\n}\n     \n   \nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z,2.);\n}\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n    if(ob.id == 1.) {\n        float f = checkerboard(p);\n        ob.material +=  .5 * vec3(f);\n    }\n\n    //ob.col = vec3(.0);\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * l.col* ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += dif + spec + ambi ;\n\n\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\n\n\nvec3 render() {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(theta), 2.0 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n    for(float i = 0.; i < 1.; i += 1./1.) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n\n        ob.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n        if(ob.id < 2. ) {\n            resCol += ob.col * alpha  ;\n       \t\talpha *= 0.1;\n            r.d = reflect(r.d, normal);\n        }\n        else {\n            resCol += ob.col * alpha *ob.transparency;\n            alpha *= (1. - ob.transparency);\n            r.d = refract2(r.d, normal,1.03);\n        }\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy ;\n    time = iTime;\n    r = raydir(uv,m);\n    update();\n\tvec3 color = render();\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n\n}\n\n\n",
  "7": "\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 80.\n#define SURF 1e-3\n#define FAR 60.\n#define ZERO min(iFrame,0)\n#define pow(a,b) pow(abs(a),(b))\n#define N 2\n#define dt iTimeDelta*4.\n#define C 10\n#define OC 20\n\n\nfloat rand(vec2 co){\n    float realRandom = iDate.w;\n    return fract(sin(realRandom+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) -0.5;\n}\nfloat time;\nfloat pupdist=1e6;\n\n// Polynomial smooth min (k = 0.1) (from IQ)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 R3(vec3 p , vec3 n, float theta){\n   return   (   p*cos(theta) +\n                n*dot(p,n) * (1.-cos(theta) ) +\n                (cross(n,p))*sin(-theta) ) ;\n}\n\nvec3 RR3(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\nstruct gl{\n    vec4 col;\n    vec4 f;\n};\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\nray r ;\n\nstruct obj_geo\n{\n    vec3 c;\n    vec3 oc;\n    vec3 acc;\n    vec3 m_mi;\n    vec3 ax;\n    vec3 ang;\n    vec3 sz;\n\n};\n\nstruct obj\n{\n\n    float d;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n    obj_geo geo;\n\n};\n\nobj obs[2] = obj[2](\n    obj(FAR ,vec3(.2) ,vec3(.5,.4,.1),\n        .5, 1., 3., 100.,1.,2. ,\n        obj_geo(vec3(0., 1.  , 1.),vec3(0.),\n        vec3(0.),vec3(1.,5.,FAR),vec3(.0),vec3(.0 ),\n        vec3(.3))),\n    obj(FAR ,vec3(.5),vec3(.5,.7,.6),\n        .5, 1., 3., 100.,1.,3. ,\n        obj_geo(vec3(0., 1.  , 0.),vec3(0.),\n        vec3(0.),vec3(1.,5.,FAR),vec3(.0),vec3(.0) ,\n        vec3(.5)))\n);\n\n\n\nfloat cylinder(vec3 p,vec3 dir,float h,float r)\n{\n    float t=dot(p,dir);\n    float d=distance(p,dir*t);\n    return length(max(abs(vec2(d,t))-vec2(r,h),vec2(0)));\n    d=max(d,-t);\n    d=max(d,t-h);\n    return d;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat rabbit(vec3 fk,vec3 pos,vec3 sz,float Rx,float time )\n{\n    float H = 5.;\n    vec3 p = fk - pos ;\n    p *= H;\n\n    float an=.5*.5*2.*6. +1./Rx*6.;\n    p.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*p.xz;\n\n    float time2=time*12.4;\n\n    p.y-=.3;\n    p.xy*=R2(cos(time2+1.)*.04);\n    p.y+=.3;\n\n    vec3 op=p;\n\n    vec3 p2=p;\n    p2.xy*=R2(cos(time2)*.4);\n\n    vec3 p3=p;\n    p3.xy*=R2(cos(time2-.0-length(p)/2.)*.13);\n\n    float d=1e4;\n    p.x=abs(p.x);\n    p2.x=abs(p2.x);\n    p3.x=abs(p3.x);\n\n    d=smin(length(p2-vec3(-.75,0.,-.1))-.4,length(p2-vec3(.75,0.,-.1))-.5,2.);\n    d=smin(d,length(p2-vec3(0,0.4,-.1))-.9,1.6);\n    d+=.1;\n\n    // Ears 1\n    d=smin(d,distance(vec3(.7,clamp(p3.y,0.,2.2),0.),p3.xyz)-.4,.14);\n    d=smax(d,-(length(p3-vec3(.7,1.7,-0.5))-.5),.2);\n\n    // Neck\n    d=smin(d,distance(vec3(0.,clamp(p.y,-1.6,-1.1),0.),p.xyz)-.6,.04);\n\n    // Legs\n    vec3 p4=op;\n    float ld=-.75;\n    p4.y-=ld;\n    p4.yz*=R2(cos(time*6.+3.1415926/1.)*.1);\n    p4.y+=ld;\n    p4.y-=max(0.,cos(time*6.+3.1415926/2.))*.1;\n    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz)-.3,.1);\n    p4=op;\n    p4.y-=ld;\n    p4.yz*=R2(cos(time*6.+3.1415926/1.*1.)*.1);\n    p4.y+=ld;\n    p4.y-=max(0.,cos(time*6.+3.1415926/2.+3.1415926/1.*1.))*.1;\n    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz*vec3(-1,1,1))-.3,.1);\n\n    // Belly\n    d=smin(d,distance(vec3(0.,-1.5,-.2),p)-.5+cos(time*3.)*.03,.4);\n\n    // Ears 2\n    d=smin(d,distance(vec3(1.1,2.3,-.1),p3)-.2,.8);\n\n    // Tail\n    d=smin(d,distance(vec3(0,-1.7,.6),p)-.3,.1);\n\n    vec3 q=vec3(0.35,.4,-1);\n\n    if(mod(time-1.,4.)>.04)\n    {\n        d=smax(d,-(cylinder(p2-q,normalize(q-p2),.3,.1)-.0001),.05);\n        d=smin(d,(length(p2-q*.9)-.2),.24);\n\n        // Eye pupils\n        if(op.x>0.)\n            pupdist=(length(p2-vec3(.39,.32,-1.))-.2);\n        else\n            pupdist=(length(p2-vec3(.28,.32,-1.02))-.2);\n\n        d=smin(d,pupdist,.005);\n    }\n\n    // Nose\n    d=smin(d,(length(p2-vec3(0,.1,-1.02))-.2),.02);\n\n    // Mouth (two states)\n    float d3=smax(-(length(p-vec3(-.05,-.29,-1.02))-.1),-(length(p-vec3(.05,-.29,-1.02))-.1),.1);\n\n    float d2=max(p2.z,distance(p2,vec3(clamp(p2.x,0.,.3),-.2,clamp(p2.z,-2.,2.)))+.01);\n\n    float time4=time/8.;\n    float gg=smoothstep(0.,1.,clamp((min(fract(time4),1.-fract(time4))-.25)*64.,0.,1.));\n    d=smax(d,mix(-d2,d3,gg),.1);\n\n    // Tooth\n    d=min(d,(length(p-vec3(.0,-.2,-1.02))-.08));\n\n    p.y+=.2;\n    p.xy*=R2(.4+cos(time2*2.)*.02);\n    // Arms\n    float armd=smin(distance(vec3(.2,clamp(p.y,-1.8,-0.),0.),p.xyz)-.2,\n                    distance(p,vec3(0.2,-1.7,0))-.2,.2);\n\n    d=smin(d,armd,.05);\n\n    return d/H;\n}\n\n\n\nfloat abox(vec3 p,vec3 pos, vec3 b) {\n    vec3 q = p-pos;\n    vec3 d = abs(q) - b ;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.) ;\n}\n\n\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    vec3 q = p-pos;\n    return length(q) - r ;\n\n}\nfloat cylinder( vec3 q, vec3 pos, vec2 h )\n{\n    vec3 p = q -pos;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) ;\n}\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat bassin(vec3 p) {\n    vec3 p1 = p  - vec3(0, 3., 0);\n    float db2 = box(p1, vec3(3., .5, 3.));\n    float dp2 = plane(p1,vec4(0, 1., 0 ,1.));\n    db2 = abs(db2);\n    db2 = max(dp2,db2);\n    return db2;\n\n}\n",
  "8": "\nvec3 wind = vec3(1.,.05 ,1. );\nvec3 gravity = vec3(.0, -.1 ,.0 );\nvec3 PC;\n\nobj_geo get_obj(int i) {\n    vec4 c = texelFetch(iChannel0, ivec2(i,C), 0);\n    vec4 oc = texelFetch(iChannel0, ivec2(i,OC), 0);\n    return   obj_geo(c.xyz, oc.xyz,  vec3(0.),  vec3(.25,.1,FAR),\n                    vec3(.0),vec3(.0),vec3(.5));\n}\n\n\nvoid correct_position(inout obj_geo o, vec3 n,float depth){\n        o.c +=   n * abs(depth + .01) ;\n}\n\n\nvoid apply_force(inout obj_geo o, vec3 force) {\n    vec3 gamma =  force * (1./o.m_mi.x);\n    o.acc += gamma;\n}\n\nvoid applyTorque(inout obj_geo o , vec3 P , vec3 impulse ){\n\n    vec3 torque = cross(P,impulse) ;\n    vec3 torque_axis = normalize(torque);\n    float torque_mag = length(torque);\n    o.ax = torque_axis;\n    o.ang.z +=   torque_mag/o.m_mi.y  ;\n}\n\nvoid applyImpulse(inout obj_geo o , vec3 impulse){\n    o.acc +=   impulse * (1./o.m_mi.x);\n}\n\nvoid apply_torque_and_impulse(inout obj_geo o,vec3 P,vec3 impulse){\n    applyImpulse(o, impulse);\n    applyTorque(o, P,impulse);\n}\n\n\nvec3 impact_normal(inout obj_geo s, inout obj_geo o){\n    vec3 n = (s.c - o.c);\n    return normalize(n);\n}\n\nvec3 impact_point(inout obj_geo s, inout obj_geo o){\n    float r1 = s.sz.x, r2 = o.sz.x;\n    if (dot(s.c,o.c) < length(o.c))\n        return s.c + (r1 / (r1 + r2)) * (o.c - s.c);\n    else\n        return o.c + (r2 / (r1 + r2)) * (s.c - o.c);\n}\n\nvec3 impact_impulse(inout obj_geo s, inout obj_geo o, vec3 pc, vec3 n){\n\n    float e = .6,\n        m1 = s.m_mi.x,\n        m2 = o.m_mi.x,\n        si = s.m_mi.y,\n        oi = o.m_mi.y;\n\n    float ism = 1./m1;\n    float iom = 1./m2;\n    vec3 vs = s.c - s.oc;\n    vec3 vo = o.c - o.oc;\n    vec3 rap = pc - s.c;\n    vec3 rbp = pc - o.c;\n    float deno = ism + iom + length(cross(rap,n))/si + length(cross(rbp,n))/oi;\n    float numer = -(1.+e) * dot( vs - vo , n);\n    float j = numer / deno;\n    vec3  f_impulse = n * j;\n    return f_impulse ;\n}\n\nvoid after_mate(inout obj_geo s, obj_geo o,vec3 pc, vec3 n) {\n    vec3 f_impulse = impact_impulse(s, o, pc, n);\n    apply_torque_and_impulse(o, pc, f_impulse);\n    apply_torque_and_impulse(s, pc, -f_impulse);\n}\n\n\n\n\nvoid process_impact(inout obj_geo s, inout obj_geo o){\n\n    float depth = s.sz.x + o.sz.x - length(s.c - o.c);\n    vec3 n = impact_normal(s, o);\n    vec3 pc = impact_point(s, o);\n    PC = pc;\n    correct_position(s, n, depth);\n    after_mate(s, o, pc, n);\n\n}\nvoid check_collision(inout obj_geo o , inout obj_geo s){\n    if (length(o.c - s.c) <= o.sz.x + s.sz.x - .3){\n        process_impact(s, o);\n    }\n}\n\nvoid check_borders(inout obj_geo o) {\n\n    float r0 = o.sz.y;\n    float up = 5.;\n    float   w = 3.,\n            down= .1,\n            bounce = .9,\n            offset = .01;\n\n    vec3 vt = o.c - o.oc;\n\n    vt *= dt*exp(-.01*dt) ;\n    if (o.c.y + r0   > up)\n            o.oc.y = o.c.y,\n            o.c.y = up - r0,\n            o.c.y +=  vt.y*bounce + offset ;\n\n    if (o.c.y - r0 < down)\n            o.oc.y = o.c.y,\n            o.c.y = down + r0,\n            o.c.y +=  vt.y*bounce - offset;\n\n    if (o.c.x + r0   > w)\n            o.oc.x = o.c.x,\n            o.c.x = w - r0,\n            o.c.x += vt.x*bounce + offset;\n\n    if (o.c.x - r0 < -w)\n            o.oc.x = o.c.x,\n            o.c.x = -w + r0,\n            o.c.x +=  vt.x*bounce - offset;\n\n    if (o.c.z + r0   > w)\n            o.oc.z = o.c.z,\n            o.c.z = w - r0,\n            o.c.z +=  vt.z*bounce + offset;\n\n    if (o.c.z - r0 < -w)\n            o.oc.z = o.c.z,\n            o.c.z = -w + r0,\n            o.c.z +=  vt.z*bounce - offset;\n}\n\n\nvoid rotate(inout obj_geo o){\n    o.ang.y += o.ang.z*dt ;\n    o.ang.x += o.ang.y*dt ;\n    o.ang *= TWO_PI;\n    //vec3 p = r.o + o.m_mi.z * r.d ;\n    //o.c = R3(o.c , o.ax,o.ang.x) ;\n\n}\nvoid translate(inout obj_geo o){\n\n\n    vec3 v = (o.c - o.oc );\n    v *= exp(-.01 * dt);\n    o.c += v  *.9 * dt ;\n    o.c += o.acc * dt *dt  ;\n\n}\n\n\n\n\nvec3 update_oc(inout obj_geo o, int idx) {\n    return o.c;\n}\n\nvec3 update_c(obj_geo o, int idx) {\n\n    vec3 npos;\n    wind.xz *= .5*sin(cos(.01*o.c.xz) + .4*iTime*(.5 + (float(idx))));\n\n    for(int i = 0; i < N; i++) {\n        obj_geo si = get_obj(i);\n        if (i != idx)\n            check_collision(si,o);\n    }\n    apply_force(o,gravity);\n    apply_force(o,wind);\n    translate(o);\n    rotate(o);\n    check_borders(o);\n    npos = o.c;\n    return npos;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n\n    int index = int(uv.x);\n    int row = int(uv.y);\n    bool isPos = row == C;\n    bool isOpos = row == OC;\n\n    if (iFrame<15) {\n        if (index < N ) {\n            if (isPos) // position\n    \t\t\tfragColor = vec4(obs[index].geo.c,0.);\n            else if (isOpos) // old pos\n            \tfragColor = vec4(obs[index].geo.oc,.0);\n            else discard;\n        }  else {\n            fragColor = vec4(-1.0);\n        }\n    } else if (index >= 0 && index < N ) {\n        obj_geo this_p = get_obj(index);\n        if (isPos) {\n            // update pos\n            vec3 npos = update_c(this_p,index);\n      \t\tfragColor = vec4(npos, .0);\n        } else if (isOpos) {\n            // update opos\n            vec3 nOpos = update_oc(this_p,index) ;\n            fragColor = vec4(nOpos, 0.0);\n    \t} else {\n            discard;\n        }\n    } else {\n        discard;\n    }\n}",
  "9": "// learning tutorial 8 , texture mapping\n// texturing sphere with checkers \n// adopted from bigwings feathers\n\n#define R iResolution\n#define PI 3.14159265359\n\n\nmat2 R2(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 T (vec3 p, float a) {\n\tp.xz *= R2(a*.6);\n    p.xy *= R2(a*.3);\n\n    return p;\n}\n\nfloat checkerboard(in vec2 p) {\n    vec2 q = floor(p*10.);\n    return mod(q.x + q.y,2.);\n}\n\nvec4 material (vec3 p,float a) {\n\n    vec3 q = normalize(T(p, a));\n    // cylindric hack :)\n   \t// vec2 uv = vec2(atan(q.x, q.z), q.y);\n    // or real spheric mapping\n    vec2 uv = vec2(atan(q.x, q.z)/(2.*PI ),acos( q.y) / PI);\n    float m = checkerboard(uv);\n    vec4 col = vec4(m);\n    return col;\n\n}\nvoid mainImage(out vec4 F, in vec2 C) {\n\n    vec2 P = (C.xy-.5*R.xy)/R.y;\n    vec4 col = vec4(.0);\n    vec3 bg = vec3(.5, .2, .3)*(P.y+.5)*2.5;\n    bg += vec3(.8, .6, .4)*(-P.y+.5);\n\n    vec3 ro = vec3(0.,0.,-3.);\n    vec3 rd = normalize(vec3(P, 1.));\n    vec3 c =  vec3(.0);\n    float t = dot(c - ro, rd);\n    vec3 p = ro + rd * t;\n    float dS = length(p - c);\n\n    if(dS < 1. ) {\n        float x = sqrt(1. - dS);\n        vec3 pF = ro + rd * (t-x) - c;\n        vec4 f = material(pF,.3*iTime);\n        vec3 pB = ro + rd * (t+x) - c;\n        vec4 b = material(pB,.3*iTime);\n\n       \tcol =   mix(b, f, f.a*f.b) +\n                vec4( .2,.3,1.,.4);\n    }\n\n    col.rgb =   mix(col.rgb, bg, .2) ;\n\n    col = pow(col, vec4(.4545));\n    F = col;\n\n}",
  "10": "#define R iResolution\n#define S smoothstep\n#define size 10.\nvoid mainImage(out vec4 F, in vec2 C) {\n    vec2 O = (C.xy-.5*R.xy)/R.y;\n\tvec2 g  = fract(abs(size*O));\n    F = vec4(S(.0,.05,vec3(min(g.x,g.y)))*.7,1.);\n}",
  "11": "// learning tutorial 8\n// tried to make Shane's tiles without loops and if conditions !\n// seems to work\n\n\n// Fabrice version :) shorter !\n\n#define rand21(p)       fract( sin( dot( p, vec2(27.609, 57.583) ) ) * 43758.5453 )\n#define randCol(i)    ( .5 + .5*cos( 6.28 * rand21( (i)*.1 ) + vec3(0, 1, 2)*1.6 ) )\n#define box(p,c,b,f)  ( length( max( abs(p-(c)) - b + f , 0. ) ) - (f) )\n#define S(v)            smoothstep(sf, .0, v)\n#define rCol(p)       ( (0.5 + 0.5 * cos((p.x*p.y) * 6.2831 + vec3(0.0, 1.0, 2.0) )*clamp(1.0 - 0.2 * length(p), 0.0, 1.0) ) )\n#define SCALE  2.\n\nvoid mainImage(out vec4 F, vec2 C) {\n    vec2 R = iResolution.xy,\n         p = SCALE* ( ( C - .5*R ) / R.y + vec2( sin(iTime*.1 ) , 0 ) ),\n        ip = floor(p);\n         p -= ip ;\n\n    float r0 = rand21(ip + 1. )*.5 + .25   ;\n\n    vec2  b = step( r0, p ),\n          S = r0 * b ,\n          B = mix(b ,1.-b, r0 );\n\n    float  d = box( p , S + B/2., B/2., .05*sqrt( min(B.x, B.y) ) ),\n          sf = SCALE/500.;\n    vec2 id = ip + S + B/2. ;\n      vec2 aa = id - exp(-d*d * 50.0);\n    vec3 pCol = rCol( aa ) ;\n    pCol = mix(pCol, pCol.xzy, .2);\n\n    vec3 col = mix(vec3(1), pCol, S( d + SCALE/250.) );\n\n    d = length( abs(p - S - B/2.) - B/2. + .1/SCALE ) - .02/SCALE;\n    col =   mix(col, pCol*.4, S(d) )\n          *( r0*.02 + .8 );\n  float g = .1;\n  col = pow( col + g*g + g*vec3(.2,.5,.4)  , vec3(2.5) );\n\n    F.rgb = pow( col, vec3(1./2.2) );\n}\n\n// original\n\n// #define R iResolution\n\n// float rand21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// vec3 randCol(vec2 id) {\n//     float rnd = rand21(id *.1);\n//     return .3 + .5*cos(6.2831853*rnd + vec3(0, 1, 2)*1.6);\n\n// }\n\n\n// float box(in vec2 p,vec2 c, in vec2 b, in float sf){\n\n//   return length(max(abs(p-c) - b + sf, 0.)) - sf;\n// }\n\n// #define SCALE 2.\n// //or vec2\n// #define SCALE2 vec2(2.,3)\n\n\n// vec4 tiles(in vec2 q){\n//     vec2 p = q * SCALE; // q * SCALE2\n//     vec2 ip = floor(p);\n//     p -= ip ;\n//     vec2 B = vec2(1., 1.);\n//     vec2 S = vec2(0.);\n//     float r0 =  rand21(ip + B )*.5 + .25   ;\n\n//     vec2 b =   step(S + B*r0, p)  ; // or smoothstep( .0 , .00001, p - S - B*r0  )\n//     vec2 r0v = vec2(r0,r0);\n//     S  = r0v * B * b ;\n//     //B  *=  ( 1.- r0v )* b + r0v * (1.- b)  ;\n//     // or simplified\n//     B  *=  mix(r0v ,1.- r0v  ,  b ) ;\n\n//     float rf = min(B.x, B.y);\n//     float d = box(p , S + B/2., B/2., .05*sqrt(rf));\n//     float sf = 1./450.*SCALE;\n//     vec2 id = ip + S + B/2. ;\n\n//     vec3 pCol = randCol(id) ;\n//     pCol = mix(pCol, pCol.xzy, .2);\n\n//     // Rectangular cell border and coloring.\n//     vec3 col = vec3(1.) ;\n//     col = mix(col, pCol, smoothstep(sf, .0, d + .004*SCALE));\n\n//     // Splitting space to produce four rivot-looking dots.\n//     p = abs(p - S - B/2.) - B/2. + .1/SCALE;\n//     float d2 = length(p) - .02/SCALE;\n//     col = mix(col, vec3(pCol*.4), 1. - smoothstep(0., sf, d2)); // Rounded pavers.\n\n\n//     // Return the color and the bump value.\n//     return vec4(col, r0);\n\n// }\n\n// vec3 render(vec2 p) {\n\n//     p.x += sin(iTime*.05 );\n//     //p.x += sin(iTime*.1 + p.y); // curved\n//     vec4 bxD = tiles(p);\n//     vec4 bxD2 = tiles(p.xy - normalize(vec2(.2,5.))*.002);\n//     float b = max(bxD2.w - bxD.w, 0.)/.002;\n//     vec3 col = bxD.xyz*(b*.02 + .8);\n//     return col;\n\n\n\n\n// }\n\n// void mainImage(out vec4 F, in vec2 C) {\n//     vec2 O = (C.xy-.5*R.xy)/R.y;\n//     vec3 col = render(O) ;\n//     col = pow(col, vec3(1. / 2.2));\n//     F = vec4(col,1.);\n// }",
  "12": "\n// temple with Fabs AA\n\n#define N 3      // pixel oversampling NxN ( only where necessary )\n#define eps .05  // similarity threshold, is case of continuous mask\n#define R  iResolution.xy\n#define ZERO min(iFrame,0)\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define T(U,l)          texelFetch(iChannel0, ivec2(U) >>l, l)\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    vec2 U = ( u - R/2. ) / R.y;\n\n    vec2 ms = iMouse.xy/R.xy ;\n    float n = float(N),\n          s = iMouse.z>0. ? iMouse.x : R.x/2.;\n    \n\n    if ( u.x > s\n         && length( T(u,1)-T(u,0) ) > eps ) { \n        O -= O;\n        for (int k=0; k<N*N; k++) {    // --- oversampling\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n; // subpixel\n            ray r = raydir(U + 2.*D/R.y, ms , R, iTime, ZERO);\n            O.rgb += render( r );\n        }\n        O /= n*n;\n    }\n    else                               // LOD#0 is ok\n        O = T( u, 0 ),\n         keyToggle(32) \n            ? O.r += .3, O.b -= .3 : 0.;\n\n    \n    O = pow( O, vec4(1./2.2) );        // to sRGB\n    \n}",
  "13": "\n#define PI 3.14159265359\n#define pi 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 80.\n#define SURF 1e-3\n#define FAR 100.\n#define REFSTEP 2.\n#define pow(a,b) pow(abs(a),(b))\n#define sqrt2 1.41421\n#define sqrt3 1.7320508\n\nint ZERO;\nvec2 R ;\nfloat time;\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\n\nstruct obj\n{\n\n    float d;\n    vec3 c;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n\n};\n\nvec2 opRepLim(in vec2 p, in float s, in vec2 lima, in vec2 limb)\n{\n    return p - s*clamp(round(p / s), lima, limb);\n}\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat plane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) + h;\n}\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    vec3 q = p-pos;\n    return length(q) - r  ;\n\n}\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat cyl(vec3 p, float r) {\n    vec3 q = p;\n\n    r -= 0.05 * q.y;\n    r -= 0.05 * pow((0.5 + 0.5 * sin(12.0 * atan(q.x, q.z))), 2.0);\n    r -= 0.1 * pow((0.5 + 0.5 * sin(2.5 * sin(3.5 * q.y))), 0.15) - 0.1;\n\n    float d = length(q.xz) - r ;\n    d = max(d, abs(q.y - .1) - 4. );\n    //d = max(d, -q.y );\n    d *= 0.7;\n    return d;\n\n}\n\n\n\nobj temple(vec3 p) {\n\n    vec3 q = p - vec3(-10.0, 1.0, -4.);\n    vec3 s = vec3(q);\n    q.xz = opRepLim(q.xz, 2.0, vec2(1.0, 1.0), vec2(8.0, 4.0));\n    vec3 qq = vec3(q.x, abs(q.y - 2.0) - 2.0, q.z);\n    float d = cyl(q, 0.4);\n    d = min(d, box(qq, vec3(0.6, 0.1, 0.6)));\n    d = max(d, - box(s - vec3(9.0, 0.0, 5.0), vec3(6.0, 4.0, 2.0)));\n\n    vec3 f = s - vec3(0.0, - 0.1, 0.0);\n    f.y = abs(f.y- 2.)-2.2;\n    vec3 sz = vec3(0.95, 0.01, 0.95);\n    f.xz = opRepLim(f.xz, 2., vec2(1.0, 1.0), vec2(8, 4.0));\n    d = min(d, box(f, sz - 0.1) - 0.2);\n\n    vec3 g = s - vec3(-3.0, - 0.6, - 3.0);\n    vec3 gsz = vec3(1.5, 0.2, 1.5);\n    g.xz = opRepLim(g.xz, 3.0, vec2(1.0, 1.0), vec2(7.0, 4.0));\n    d = min(d, box(g, gsz - 0.2) - 0.2);\n\n\n    obj templ = obj(d ,vec3(.0),vec3(.7,.7,.7),vec3(0.), 1., .5, 1.5, 150., 1., 2.);\n    return templ;\n\n}\n\n\nobj scene(vec3 p) {\n    float b = plane(p, vec3(0.0, 1.0, 0.0), 0.1);\n    obj flor = obj(b ,vec3(.0),vec3(.8,.8,.8),vec3(0.), .8, .7, 3., 100., 1., 1.);\n    obj tmpl = temple(p);\n\n    tmpl = uop(tmpl,flor);\n\n\n    return tmpl;\n\n\n}\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m, vec2 Res,float tme,int Z) {\n\n\tR = Res;\n    time = tme;\n    ZERO = Z ;\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.;\n    \n    float ang = sin(0.2 * time*PI + TWO_PI*m.x) * .5;\n    vec3 camR = vec3( sin(ang + m.x), 0. , cos(ang+ m.y));\n    r.o = vec3(.0, 2.0, 20.0) + camR;\n    //r.o = vec3(0., 5., -10.);\n    r.t = vec3(0.);\n\n    r.o.yz *= R2( - m.y * PI/4. );\n    r.o.xz *= R2( - m.x * TWO_PI + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\n\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += s.d;\n    }\n\n    s.d = t;\n    return s;\n}\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n\n    //ob.col = vec3(.0);\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * l.col* ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += dif + spec + ambi ;\n\n\n}\n\n\nvec3 draw_star(vec3 p, star s, vec3 rd, float d, float i)\n{\n    vec3 lp = s.pos - p;\n    float l = dot(lp,lp);\n    float a = max(abs(dot(normalize(lp), rd)), 0.1);\n    float foff = smoothstep(FAR/15. , .0, (l - s.rad) /d ) ;\n    float g = pow(a,5000.) * foff ;\n   return s.col * g * i;\n}\n\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 3.  ,theta= time*.5;\n    vec3 spos = vec3(2. + radius * cos(theta), 3.0 + sin(theta ), 2.+ radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n    for(float i = 0.; i < 1.; i += 1./REFSTEP) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n        vec3 s = draw_star(p,blue,r.d,ob.d,10.);\n        resCol += s ;\n\n        ob.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n        resCol += ob.col * alpha  ;\n   \t\talpha *= 0.1;\n        r.d = reflect(r.d, normal);\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n",
  "14": "\n#define R  iResolution.xy\n#define ZERO min(iFrame,0)\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  U = ( u - .5*R ) / R.y;      // normalized centered coords\n    vec2 m = iMouse.xy/R.xy ;\n    ray r = raydir(U,m,R,iTime,ZERO);\n\tvec3 color = render(r);\n\n    O = vec4( color, 1. );\n}",
  "15": "// Learning tutorial 9 \n\n// testing mazes !\n\n\n\n#define rand21(p)       fract( sin( dot( p, vec2(27.609, 57.583) ) ) * 43758.5453 )\n#define rnd( x)    fract(1000.*sin(345.2345*x))\n#define id(u)   floor(u.x) + 25. *floor(u.y)\n#define box(p,c,b,f)  ( length( max( abs(p-(c)) - b + f , 0. ) ) - (f) )\n#define rCol(p)       ( (0.25 + 0.5 * cos((1. -p.x*p.y) * 6.2831 + vec3(0.1, 2.0, 3.0) )*clamp(1.0 - 0.2 * length(p), 0.0, 1.0) ) )\n\n#define scale 15.\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat maze(vec2 u) {\n    float n = id(u);  u = fract(u);\n    return smoothstep( .0, .45 , (rnd(n) > .5) ? u.x:u.y  );\n    //return smoothstep( .1, .0 , (rnd(n) > .5) ? u.x:u.y  );\n\n}\n\n\nvoid mainImage( out vec4 F, in vec2 U )\n{\n\n    \n    vec2 R = iResolution.xy;\n    U = (U-.5*R)/R.x;\n    U +=  .2*U * R2(.3*iTime) ; \n    U *= 2.;\n    vec2 b  = vec2(.5) ;\n    float f = .05;\n\tvec2 o = vec2(.0) ;\n    \n    // test mapping the maze to the box uv \n    // working thanx Spalmer !\n    \n    vec2 buv =  (U - o) /( b + .5*f) ;\n    buv = .5*buv - .5;\n    //buv *= R2(-.1*iTime) ;\n\n    float d = box(U,o,b,f);\n    float m   =  abs(maze( buv*scale ) - .2 ) + .2;\n    d = smoothstep( .01 , .0 ,  d ) ;\n    \n    m -=  d* ( .5*sin(iTime*.5) + 1.25 )  ; // texture is under :) comment this to see it   \n    \n    m *=  d  ; \n    vec3 col = vec3((m)) ;\n\tcol *= texture(iChannel0,buv).rgb;\n    \n    float lum = .35 ;\n    \n    col = mix(col, rCol(vec2(m ,d*.5)) , lum);\n    col = mix(col, rCol(vec2(1.*m,.25)) + d-.5*m , lum );\n\t\n    \n    F = vec4(col,1.0);\n    F.rgb = pow( col, vec3(1./2.2) );\n}",
  "16": "// testing a noise function by Del https://www.shadertoy.com/view/Ws3yWn\n\n\n#define ZERO min(iFrame,0)\n\n\n\nobj scene(vec3 p) {\n\n\n\n    float w = 2.8, h1 = .1 ,h2 = .1;\n    vec3 p0 = vec3(0, h1, 0); \n\n    float a = 4., b=1. , k = -.2 , h = .25;\n\n    vec3 q = p;\n    q.xz += a*((p.y)) - b ;\n    //q.xz += a*mod(abs(p.y)*10. , 2. ) - b ;\n    float dw =  eau(q ,.5*iTime) ;\n    float dp = box(p , p0, vec3(w , h2 + .35*sqrt(dw), w))  ;\n    spheres(p );\n    obj sph = ob_s;\n    float db = bassin(p);\n    //dp  +=  h*dw + k;\n\n    obj pln = obj(dp ,vec3(.059, .059, .875),vec3(0.), .3, 1., 3., 10.,1., 3.,pl_bs_geo);\n    obj bsn = obj(db,vec3(1.),vec3(0.),  .5, 1., 3., 100.,.1, 4.,pl_bs_geo);\n\n    obj r = uop(pln,bsn);\n    r = uop(r,sph);\n\n    return r;\n\n\n}\n\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += s.d;\n    }\n\n    s.d = t;\n    return s;\n}\n\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z,2.);\n}\n\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n    if(ob.id ==3. ) {\n        float f = checkerboard(p);\n        ob.material *= 0.1 + f*vec3(1.);\n    }\n\n    //ob.col = vec3(.0);\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * l.col* ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += dif + spec + ambi*2. ;\n\n\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\nvec3 draw_star(vec3 p, star s, vec3 rd, float d, float i)\n{\n    vec3 lp = s.pos - p;\n    float l = dot(lp,lp);\n    float a = max(abs(dot(normalize(lp), rd)), 0.1);\n    float foff = smoothstep(FAR/15. , .0, (l - s.rad) /d ) ;\n    //float foff = step( (l - s.rad)/d , FAR/15. ) ;\n    float g = pow(a,5000.) * foff ;\n   return s.col * g * i;\n}\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(theta), 2.0 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n\n    for(float i = 0.; i < 1.; i += 1./REFSTEP) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n\n        ob.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n        if(ob.id < 4. ) {\n            resCol += ob.col * alpha  ;\n       \t\talpha *= 0.1;\n            r.d = reflect(r.d, normal);\n        }\n        else {\n            resCol += ob.col * alpha *ob.transparency;\n            alpha *= (1. - ob.transparency);\n            r.d = refract2(r.d, normal,1.03);\n        }\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 ms = iMouse.xy/iResolution.xy ;\n    vec3 color = vec3(.0),tot;\n\t\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    update(iTime);\n    ray r = raydir(uv,ms);\n    color = render(r);\n\n    color = sqrt( color );\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n\n}\n\n\n",
  "17": "\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 80.\n#define SURF 1e-5\n#define FAR 60.\n#define REFSTEP 4.\n#define pow(a,b) pow(abs(a),(b))\n\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\nstruct obj_geo\n{\n    vec3 c;\n    vec3 oc;\n    vec3 acc;\n    float m;\n    float mi;\n    vec3 t_ax;\n    float ang;\n    float ang_v;\n    float ang_acc;\n    vec3 sz;\n};\n\nstruct obj\n{\n\n    float d;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n    obj_geo geo;\n\n};\n\nobj ob_s = obj(FAR ,vec3(.86,.77,.75),vec3(0.), .5, 1., 3., 100.,1.,2. ,\nobj_geo(vec3(0., 1.  , 0.),vec3(0.),vec3(0.),1.,.5,vec3(.0),.0,.0,.0 ,vec3(.5)));\n\nobj_geo pl_bs_geo = obj_geo(vec3(0., 1.  , 0.),vec3(0.),vec3(0.),1.,.5,vec3(.0),.0,.0,.0 ,vec3(1.));\n\nfloat st = 0., et = 0.;\nfloat time;\nconst vec3 wcol = vec3(.059, .059, .755);\n\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.;\n    r.o = vec3(0., 6., -10.);\n    r.t = vec3(.5);\n\n    // float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI/4. + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\nfloat rand(vec2 co){\n    float realRandom = iDate.w;\n    return fract(sin(realRandom+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) -0.5;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\n\n\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;\n    return k/scale;\n}\n\n\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat plane(vec3 p,vec3 p0, vec4 n) {\n  return dot(p-p0,n.xyz) + n.w;\n}\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    return length(p-pos) - r ;\n\n}\n\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat bassin(vec3 p) {\n    float w = 3., h = 2.;\n    vec3 p0 =  vec3(0, 1.75, 0);\n    float db2 = box(p , p0, vec3(w, h, w));\n    float dp2 = plane(p, p0,vec4(0, 1., 0, 1.));\n    db2 = abs(db2);\n    db2 = max(dp2,db2);\n    return db2;\n\n}\n\nvoid spheres(vec3 p) {\n\n    float ds = sphere(p,ob_s.geo.c , ob_s.geo.sz.x);\n    ob_s.d = ds ;\n}\n\n\n\nfloat eau( vec3 pos, float t )\n{\n    float rad =  (1.0/(3.141*2.0)*100.);\n    vec3 dp =  vec3(pos.z, atan(pos.x, pos.y) * rad, rad-length(pos.xy));\n    float n1 = noise(dp+vec3(0.0,t*1.0,0.0),1.0,3.57,.83);\n    float n2 = noise(dp+vec3(0.0,t*2.0,0.0), 2.0, 1.87,3.13);\n\n    n1 = smax(n1,n2,.5);\n    float n3 = noise(pos+vec3(0.0,t*2.0,0.0),1.0,3.57,1.83)*2.0;\n    float disp = (sin(pos.z*1.3+t*1.1+pos.x*0.4)+cos(n3+t*1.3+pos.z*1.5+sin(t*2.2+pos.x*1.25)))*0.1;\n\n    float d2 = dot(pos,vec3(.0,1.0,.0)) + 2.*  disp;\n    d2 = smin(n1,d2,.5);\n    return clamp(d2,0.,1.);\n}\n\n\nvoid update(float dt) {\n\n \tfloat t  = dt;\n    float tx = mod( t ,4. * 2.6);\n    float ty = mod(t,1.);\n    obj_geo og = ob_s.geo;\n    vec3 pos = og.c;\n    float px = abs( tx - 2.*2.6)-2.6;\n    float pz = cos( .1*t);\n    pos.xz  = vec2(px,pz);\n    pos.y = .4+ 5.0*ty - 0.5*9.8*ty*ty;\n    pos  *= exp(-.01*t);\n    if (t > 15.) pos.y = .5*eau(pos,.5*t);\n    pos.y = max(og.sz.x+.3,abs(pos.y));\n    ob_s.geo.c = pos;\n\n}\n\n",
  "18": "// learning tutorial 10 ! or 11 !?\n// attempt water by testing a noise function by Del https://www.shadertoy.com/view/Ws3yWn\n// seems working :)\n\n#define ZERO min(iFrame,0)\n\n\n\nobj scene(vec3 p) {\n\n\n\n    float w = 2.9, h1 = .1 ,h2 = .3;\n    vec3 p0 = vec3(0, h1, 0); \n\n    float a = 4., b = 1. , k = -.2 , h = .25;\n\n    vec3 q = p;\n    q.xz += a*((p.y)) - b ;\n    float dw =  eau(q,.5*iTime ) ;\n    float dp = box(p , p0, vec3(w , h2 + .4*sqrt(dw), w))  ;\n    spheres(p );\n    obj sph = ob_s;\n    float db = bassin(p);\n    //dp  +=  h*dw + k;\n\n    obj pln = obj(dp ,vec3(.059, .059, .875),vec3(0.), .3, 1., 3., 10.,1., 3.,pl_bs_geo);\n    obj bsn = obj(db,vec3(1.),vec3(0.),  .5, 1., 3., 100.,.1, 4.,pl_bs_geo);\n\n    obj r = uop(pln,bsn);\n    r = uop(r,sph);\n\n    return r;\n\n\n}\n\n\n\n\n\n\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += s.d;\n    }\n\n    s.d = t;\n    return s;\n}\n\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z,2.);\n}\n\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n    if(ob.id < 2.) {\n        float f = checkerboard(p);\n        ob.material *= 0.1 + f*vec3(1.);\n    }\n\n    //ob.col = vec3(.0);\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * l.col* ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += dif + spec + ambi*2. ;\n\n\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\nvec3 draw_star(vec3 p, star s, vec3 rd, float d, float i)\n{\n    vec3 lp = s.pos - p;\n    float l = dot(lp,lp);\n    float a = max(abs(dot(normalize(lp), rd)), 0.1);\n    float foff = smoothstep(FAR/15. , .0, (l - s.rad) /d ) ;\n    //float foff = step( (l - s.rad)/d , FAR/15. ) ;\n    float g = pow(a,5000.) * foff ;\n   return s.col * g * i;\n}\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(theta), 2.0 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n\n    for(float i = 0.; i < 1.; i += 1./REFSTEP) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n\n        ob.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n        if(ob.id < 4. ) {\n            resCol += ob.col * alpha  ;\n       \t\talpha *= 0.1;\n            r.d = reflect(r.d, normal);\n        }\n        else {\n            resCol += ob.col * alpha *ob.transparency;\n            alpha *= (1. - ob.transparency);\n            r.d = refract2(r.d, normal,1.03);\n        }\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 ms = iMouse.xy/iResolution.xy ;\n    vec3 color = vec3(.0),tot;\n\t\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    update(iTime);\n    ray r = raydir(uv,ms);\n    color = render(r);\n\n    color = sqrt( color );\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n\n}\n\n\n",
  "19": "\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 80.\n#define SURF 1e-5\n#define FAR 60.\n#define REFSTEP 4.\n#define pow(a,b) pow(abs(a),(b))\n\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\nstruct obj_geo\n{\n    vec3 c;\n    vec3 oc;\n    vec3 acc;\n    float m;\n    float mi;\n    vec3 t_ax;\n    float ang;\n    float ang_v;\n    float ang_acc;\n    vec3 sz;\n};\n\nstruct obj\n{\n\n    float d;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n    obj_geo geo;\n\n};\n\nobj ob_s = obj(FAR ,vec3(.86,.3,.1),vec3(0.), .5, 1., 3., 100.,1.,2. ,\nobj_geo(vec3(0., .5  , 0.),vec3(0.),vec3(0.),1.,.5,vec3(.0),.0,.0,.0 ,vec3(.5,.2,.5)));\n\nobj_geo pl_bs_geo = obj_geo(vec3(0., 1.  , 0.),vec3(0.),vec3(0.),1.,.5,vec3(.0),.0,.0,.0 ,vec3(1.));\n\nfloat st = 0., et = 0.;\n\n\nfloat rand(vec2 co){\n    float realRandom = iDate.w;\n    return fract(sin(realRandom+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) -0.5;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\n\n\nfloat noise(vec3 p,float scale, float s1,float s2)\n{\n    p*=scale;\n    float k = dot(sin(p - cos(p.yzx*1.57)), vec3(.333))*s1;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*s2;\n    return k/scale;\n}\n\n\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    return length(p-pos) - r ;\n\n}\n\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat bassin(vec3 p) {\n    float w = 3., h1 = 1.7,h2 = 2.;\n    vec3 p1 = p  - vec3(0, h1, 0);\n    float db2 = box(p1, vec3(w, h2, w));\n    float dp2 = plane(p1,vec4(0, 1., 0, 1.));\n    db2 = abs(db2);\n    db2 = max(dp2,db2);\n    return db2;\n\n}\n\nfloat torus( in vec3 p, vec3 pos, vec2 rad )\n{\n    p = p - pos ;\n    float d = length( vec2(length(p.xz)-rad.x,p.y) )-rad.y;\n\n    return d;\n}\n\n\nvoid spheres(vec3 p) {\n\n    //float ds = sphere(p,ob_s.geo.c , ob_s.geo.sz.x);\n    float ds = torus(p,ob_s.geo.c , ob_s.geo.sz.xy);\n    ob_s.d = ds ;\n}\n\n\n\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.;\n    r.o = vec3(0., 6., -10.);\n    r.t = vec3(.5);\n\n    // float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI/4. + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\nfloat eau( vec3 pos, float t )\n{\n    float rad =  (1.0/(3.141*2.0)*100.);\n    vec3 dp =  vec3(pos.z, atan(pos.x, pos.y) * rad, rad-length(pos.xy));\n    float n1 = noise(dp+vec3(0.0,t*1.0,0.0),1.0,3.57,.83);\n    float n2 = noise(dp+vec3(0.0,t*2.0,0.0), 2.0, 1.87,3.13);\n\n    n1 = smax(n1,n2,.5);\n    float n3 = noise(pos+vec3(0.0,t*2.0,0.0),1.0,3.57,1.83)*2.0;\n    float disp = (sin(pos.z*1.3+t*1.1+pos.x*0.4)+cos(n3+t*1.3+pos.z*1.5+sin(t*2.2+pos.x*1.25)))*0.1;\n\n    float d2 = dot(pos,vec3(.0,1.0,.0)) + 2.*  disp;\n    d2 = smin(n1,d2,.5);\n    return clamp(d2,0.,1.);\n}\n\n\nvoid update(float dt) {\n\n \tfloat t  = dt;\n    float tx = mod( t ,4. * 2.6);\n    float ty = mod(t,1.);\n    obj_geo og = ob_s.geo;\n    vec3 pos = og.c;\n    float px = abs( tx - 2.*2.6)-2.6;\n    float pz = cos( .1*t);\n    pos.xz  = vec2(px,pz);\n    pos.y = .1+ 5.0*ty - 0.5*9.8*ty*ty;\n    pos  *= exp(-.05*t);\n    if (t > 15.) pos.y = .5*eau(pos,.5*t);\n    pos.y = max(og.sz.x+.2,abs(pos.y));\n    ob_s.geo.c = pos;\n\n}\n\n",
  "20": "\n// learning tutorial 12 \n// collision with rotation upon impact\n\n\n#define ZERO min(iFrame,0)\n\n\nvoid load_obj(int i) {\n    vec4 pos = texelFetch(iChannel0, ivec2(i,POS), 0);\n    vec4 opos = texelFetch(iChannel0, ivec2(i,OPOS), 0);\n    vec4 ang = texelFetch(iChannel0, ivec2(i,AN), 0);\n    vec4 axis = texelFetch(iChannel0, ivec2(i,AX), 0);\n\n    rbody rb = obs[i].rb;\n    rb.pos = pos.xyz;\n    rb.opos = opos.xyz;\n    rb.axis = axis.xyz;\n    rb.ang = ang.xyz;\n    obs[i].rb  = rb ;\n }\n\nvoid rbodies(  vec3 p , int idx ) {\n\n    obj o = obs[idx] ;\n    if (idx == 0)\n        o.d = box(p, o.rb.pos , o.rb.dim);\n    else if (idx == 1)\n        o.d = torus(p,  o.rb.pos , o.rb.dim.xy);\n    else if (idx == 2)\n        o.d = sphere(p,  o.rb.pos , o.rb.dim.x);\n    \n    obs[idx] = o;\n\n}\nvoid update( vec3 p , int i) {\n\n        load_obj(i);\n        rbody r = obs[i].rb ;\n    \tp -= r.pos;\n        p =   R3( p , r.axis , r.ang.x);\n        p += r.pos;        \n        rbodies(p,i);\n    \t\n}\n\n\n\nobj scene(vec3 p) {\n\n\n    float dp = box(p ,vec3(0.) , vec3(5.,.1,5.) )  ;\n    \n    for(int i = 0; i < NP; i++) {\n        update(p,i);\n   }\n\t\n\n    obj bx1 = obs[0];\n    obj bx2 = obs[1];\n    obj sph = obs[2];\n    pln.d = dp;\n\n    obj r = uop(bx1,bx2);\n    r = uop(r,sph);\n    r = uop(r,pln);\n\n    return r;\n\n\n}\n\n\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        s.id > 3. ?  t += abs(s.d) : t += s.d ;\n    }\n\n    s.d = t;\n    return s;\n}\n\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.mtr.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.mtr.col * Kd * l.col* ob.mtr.diffuse;\n    vec3 spec = ob.mtr.col * Ks * l.col*  ob.mtr.specular;\n    vec3 ambi = ob.mtr.col *  ob.mtr.amb;\n\n    ob.mtr.col *= dif + spec + ambi ;\n\n\n}\n\n\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(theta), 2.0 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n\n    for(float i = 0.; i < 1.; i += 1./REF) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tnormal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n\n        ob.mtr.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n\n        resCol += ob.mtr.col * alpha  ;\n        alpha *= .1;\n        r.d = reflect(r.d, normal);\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 ms = iMouse.xy/iResolution.xy ;\n    vec3 color = vec3(.0);\n\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    ray r = raydir(uv,ms);\n    color = render(r);\n\n    //color = sqrt( color );\n\n\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n\n}\n\n\n",
  "21": "\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 60.\n#define SURF 1e-2\n#define FAR 60.\n#define REF 2.\n#define pow(a,b) pow(abs(a),(b))\n#define NP 3\n#define POS  0\n#define OPOS 1\n#define AN 2\n#define AX 3\n\n\n\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\nstruct rbody\n{\n    vec3 pos;\n    vec3 opos;\n    vec3 v;\n    vec3 acc;\n    vec2 m;\n    vec3 axis;\n    vec3 ang;\n    vec3 dim;\n};\n\nstruct material {\n    vec3 col;\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n\n};\n\nstruct obj\n{\n\n    float d;\n    float id;\n    material mtr;\n    rbody rb;\n\n};\n\nconst vec3 wcol = vec3(.059, .059, .855);\nvec3 normal;\nobj obs[3] = obj[3](\n    \n    obj(FAR , 2.,\n    material(vec3(.8,.8,.7),.5, 1., 3., 100.,.1),\n    rbody(vec3(0.,1.,0.),vec3(0.),vec3(0.),vec3(0.),vec2(2.,1.),vec3(.0),vec3(.0) ,vec3(.5))\n    ),\n \n    obj(FAR , 3.,\n    material(vec3(.6,.5,.1),.5, 1., 3., 100.,.1),\n    rbody(vec3(1.,2.,2.),vec3(0.),vec3(0.),vec3(0.),vec2(1.,.5),vec3(.0),vec3(.0) ,vec3(.5,.2,.5))\n    ) ,\n\n\tobj(FAR , 4.,\n    material(vec3(.8,.2,.2),.5, 1., 3., 100.,.1),\n    rbody(vec3(2.,3.,0.),vec3(0.),vec3(0.),vec3(0.),vec2(2.,1.),vec3(.0),vec3(.0) ,vec3(.5))\n    )\n\n);\n\n\nobj pln = obj(FAR , 1.,\n    material(wcol,.5, 1., 3., 100.,.1),\n    rbody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec2(1.,.5),vec3(.0),vec3(.0) ,vec3(3.,.1,3.)));\n\n\n\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R3(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.;\n    r.o = vec3(0., 6., 10.);\n    r.t = vec3(.5);\n\n    // float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI/4. + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\n\nfloat torus( in vec3 p, vec3 pos, vec2 rad )\n{\n    p = p - pos ;\n    float d = length( vec2(length(p.xz)-rad.x,p.y) )-rad.y;\n\n    return d;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n    float dd = length(max(d, 0.));\n    return  dd + min(max(d.x, max(d.y, d.z)), 0.) - .1 ;\n}\n\n\nfloat plane(vec3 p,vec3 p0, vec4 n) {\n  return dot(p-p0,n.xyz) + n.w;\n}\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    return length(p-pos) - r ;\n\n}\n\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\n",
  "22": "#define dt iTimeDelta*3.\n\n\nvec3 wind = vec3(.4,.1 ,.35 );\nvec3 gravity = vec3(.0, -.2 ,.0 );\nfloat bounce = .95;\nfloat friction = .8;\n\nobj load_obj(int i) {\n    vec4 pos = texelFetch(iChannel0, ivec2(i,POS), 0);\n    vec4 opos = texelFetch(iChannel0, ivec2(i,OPOS), 0);\n    vec4 ang = texelFetch(iChannel0, ivec2(i,AN), 0);\n    vec4 axis = texelFetch(iChannel0, ivec2(i,AX), 0);\n\n    obj o = obj(FAR , 1.,\n    material(vec3(0.),.5, 1., 3., 100.,.1),\n    rbody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec2(1.,.5),vec3(.0),vec3(.0) ,vec3(.5)));\n\n\n    rbody rb = o.rb;\n    rb.pos = pos.xyz;\n    rb.opos = opos.xyz;\n    rb.axis = axis.xyz;\n    rb.ang = ang.xyz;\n    o.rb  = rb ;\n    return o ;\n }\n\n\nvoid correct_position(inout rbody rb, vec3 n,float depth){\n        rb.pos +=   n * abs(depth + .2) ;\n}\n\n\nvoid apply_force(inout rbody rb, vec3 force) {\n    vec3 gamma =  force * (1./rb.m.x);\n    rb.acc += gamma;\n}\n\nvoid applyTorque(inout rbody rb , vec3 P , vec3 impulse ){\n\n    vec3 torque = cross( P , impulse) ;\n    vec3 torque_axis = normalize(torque);\n    float torque_mag = length(torque);\n    rb.axis = torque_axis;\n    rb.ang.z +=   torque_mag/rb.m.y  ;\n}\n\nvoid applyImpulse(inout rbody rb , vec3 impulse){\n    rb.acc +=   impulse * 1./rb.m.x;\n}\n\nvoid apply_torque_and_impulse(inout rbody rb,vec3 P,vec3 impulse){\n    applyImpulse(rb, impulse);\n    applyTorque(rb, P,impulse);\n}\n\n\nvec3 impact_normal(inout rbody s, inout rbody rb){\n    vec3 n = (s.pos - rb.pos);\n    return normalize(n);\n}\n\nvec3 impact_point(inout rbody s, inout rbody rb){\n    float r1 = s.dim.x, r2 = rb.dim.x;\n    if (dot(s.pos,rb.pos) < length(rb.pos))\n        return s.pos + (r1 / (r1 + r2)) * (rb.pos - s.pos);\n    else\n        return rb.pos + (r2 / (r1 + r2)) * (s.pos - rb.pos);\n}\n\nvec3 impact_impulse(inout rbody s, inout rbody rb, vec3 pc, vec3 n){\n\n    float e = .7,\n        m1 = s.m.x,\n        m2 = rb.m.x,\n        si = s.m.y,\n        oi = rb.m.y;\n\n    float ism = 1./m1;\n    float iom = 1./m2;\n    vec3 vs = s.pos - s.opos;\n    vec3 vo = rb.pos - rb.opos;\n    vec3 rap = pc - s.pos;\n    vec3 rbp = pc - rb.pos;\n    float deno = ism + iom + length(cross(rap,n))/si + length(cross(rbp,n))/oi;\n    float numer = -(1.+e) * dot( vs - vo , n);\n    float j =  (deno == 0.) ? .001 : numer / deno;\n    return  n * j * 10. ;\n}\n\nvoid after_mate(inout rbody s, inout rbody rb,vec3 pc, vec3 n) {\n    vec3 f_impulse = impact_impulse(s, rb, pc, n);\n    apply_torque_and_impulse(rb, pc, f_impulse);\n    apply_torque_and_impulse(s, pc, -f_impulse);\n}\n\n\n\n\nvoid process_impact(inout rbody s, inout rbody rb){\n\n    float depth = s.dim.x + rb.dim.x - length(s.pos - rb.pos);\n    vec3 n = impact_normal(s, rb);\n    vec3 pc = impact_point(s, rb);\n    correct_position(s, n, depth);\n    after_mate(s, rb, pc, n);\n\n}\nvoid check_collision(inout rbody rb , inout rbody s){\n    if (length(rb.pos - s.pos) <= (rb.dim.x + s.dim.x) +.2){\n        process_impact(s, rb);\n    }\n}\n\n\nvoid check_borders(inout rbody rb) {\n\n    float r0 = rb.dim.x;\n    float up = 4.;\n    float   w = 4.8,\n            down= .2;\n\n    if  ( rb.pos.x + r0   > w )  {\n            rb.pos.x =   w -r0 ;\n            rb.opos.x *= -bounce ;\n\n    }\n\n    if  ( rb.pos.x - r0 < -w ){\n            rb.pos.x =   -w + r0 ;\n            rb.opos.x *= -bounce ;\n\n    }\n\n\n    if  ( rb.pos.y - r0 < down ){\n            rb.pos.y = down + r0  ;\n            rb.opos.y *= -bounce  ;\n\n    }\n\n    if  ( rb.pos.y + r0   > up )  {\n            rb.pos.y = up - r0 ;\n            rb.opos.y *= - bounce ;\n\n    }\n\n\n    if  ( rb.pos.z + r0   > w )  {\n            rb.pos.z =   w -r0 ;\n            rb.opos.z *= -bounce ;\n\n    }\n\n    if  ( rb.pos.z - r0 < -w ){\n            rb.pos.z =   -w + r0 ;\n            rb.opos.z *= -bounce ;\n\n    }\n\n\n\n}\n\n\nvoid rotate(inout rbody rb){\n    rb.ang.y = rb.ang.z * dt ;\n    rb.ang.x = rb.ang.y * exp(-.1 * dt) ;\n    rb.ang.z *= friction;\n\n}\nvoid translate(inout rbody rb){\n\n    //rb.opos *= exp(-.01 * dt) ;\n    rb.opos +=  rb.acc  * dt ;\n    rb.pos += rb.opos * friction * dt ;\n    rb.acc = vec3(0.);\n}\n\n\n\nvec3 update_an(rbody rb) {\n    return rb.ang;\n}\nvec3 update_ax( rbody rb) {\n    return rb.axis;\n}\n\nvec3 update_op(rbody rb) {\n    return rb.opos;\n}\n\nvec3 update_p( rbody rb) {\n    return rb.pos;\n}\n\n\nvoid animate(inout obj o, int idx) {\n    rbody rb = o.rb;\n    wind *= .25*sin(cos(.1*rb.pos.y) + .1*iTime*(.5 + (float(idx))));\n\n    apply_force(rb,gravity);\n    apply_force(rb,wind);\n    translate(rb);\n    rotate(rb);\n    for(int i = 0; i < NP; i++) {\n        obj so = load_obj(i);\n        rbody sr = so.rb ;\n        if (i != idx){\n\t      check_collision(sr,rb);\n        }\n        so.rb = sr;\n    }\n    \n    check_borders(rb);\n\n   o.rb = rb ;\n\n}\n\n\n\n\n\nvoid mainImage( out vec4 F, in vec2 U ) {\n\n    F = vec4(0.);\n    int index = int(U.x);\n    int row = int(U.y);\n    if(index > 2 || row > 3) {\n        discard;\n    }\n\n    if (iFrame < 10) {\n            if (row == POS)\n                F = vec4(obs[index].rb.pos,0.);\n            else if (row == OPOS)\n                F = vec4(obs[index].rb.opos,.0);\n            else if (row == AN)\n                F = vec4(obs[index].rb.ang,.0);\n            else if (row == AX)\n                F = vec4(obs[index].rb.axis,.0);\n        }\n    else{\n\n      obj this_ob = load_obj(index);\n      animate(this_ob,index);\n        if (row == POS) {\n            vec3 npos = update_p(this_ob.rb);\n            F = vec4(npos, .0);\n        } else if (row == OPOS) {\n                vec3 nOpos = update_op(this_ob.rb) ;\n                F = vec4(nOpos, 0.0);\n        } else if (row == AN) {\n            vec3 an = update_an(this_ob.rb) ;\n            F = vec4(an, 0.0);\n        } else if (row == AX) {\n            vec3 nax = update_ax(this_ob.rb) ;\n            F = vec4(nax, 0.0);\n        }else {\n            F = vec4(-1.0);\n        }\n    }\n}",
  "23": "// Learning tutorial 13\n//pseudo cloud marching mechanism\n// based on Shane small noise and Hazel.\n\n\n// use the mouse to oriente the face :)\n\n\n\n#define ZERO min(iFrame,0)\n\n\n\nobj scene( vec3 p )\n{\n\n    vec3 q = p*3.;\n    float t = iTime;\n     q -=  1.0 * sin(.2*vec3(t, .0, t)) ;\n    vec3 vc = vec3(.8+.1*sin(1.*t -.5),.01 ,.7) ;\n    vec3 pt = vec3(.0,-1. , .0 ) ;\n    float f = N31(q);\n    f *= .02;\n    float s0 = sphere(p , vec3(.0,1.,-1.5) , .3+.2*sin(.4*t));\n    float s1 = sphere(p , vec3(.0,1.,1.5) , .3+.2*sin(.4*t));\n    float b = box(p , vec3(.0,-1.5,0.) , vc,.0);\n    s0 = smin(s0 ,s1, 1.5) ;\n    b = smin(b ,s0, .5) ;\n    p.yx *= R2(.5*t);\n    float g = torus(p , pt , vec2(4.,.01 ));\n    g = smin(g ,b, 2.) ;\n    f += g *.1;\n    cld.sdi.x = f ;\n    return cld;;\n}\n\n\nvec3 render(ray r) {\n\n    float rd = 6.  ,t = iTime*.25;\n    vec3 sp = vec3(rd*cos(1.5*t), .5, rd*sin(t));\n    yellow = star(sp, vec3(1.,1.,.2), 1. );\n    const float d = 1.5;\n    const float s = .1;\n    float vis = 1.;\n    float light = 0.;\n    vec3 p = r.o  ;\n    vec3 lp = normalize(yellow.pos-p);\n    obj ob  , dob ;\n    vec3 color = vec3(0.);\n    float vs = .0  ;\n\n\n    for ( float i= .0; i < 1.; i+=1./ITR )\n    {\n        ob = scene(p) ;\n        float h = ob.sdi.x;\n        lp = normalize(yellow.pos-p);\n        vs = smoothstep(EPSILON,s,h);\n        h = max(h,EPSILON);\n        if ( vs < 1. )\n        {\n            float nvis = vis * pow(vs,h*d);\n            float k = scene(p+ lp * s).sdi.x ;\n            light += (vis - nvis) * smoothstep( -1., 1., (k - h) );\n            vis = nvis;\n        }\n\n        if ( vs <= 0. ) break;\n        ob.sdi.y += h ;\n        p += h*r.d;\n\n    }\n\n\n    color += .5*vec3(.1,.1,2.) * pow( yellow.col,vec3(.25));\n    vec3 res = vec3(light) ;\n    color = mix(res ,  color , vis);\n    return color ;\n\n}\n\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec2 ms = iMouse.xy/R ;\n    vec2 uv = (U.xy-.5*R.xy)/R.y;\n    ray r = raydir(uv,ms);\n    o.rgb = render(r);\n    o = pow(o,vec4(1./2.2));\n}",
  "24": "\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 50.\n#define SURF 1e-3\n#define FAR 60.\n#define REFSTEP 2.\n#define pow(a,b) pow(abs(a),(b))\n\nstruct star{ vec3 pos; vec3 col; float rad; };\nstruct ray { vec3 o; vec3 d; vec3 t; float zoom; };\nstruct material { vec3 col;\n    vec3 ads; // amb, diff, spec\n    vec3 stg; // shiness , transparency,glow\n};\n\nstruct obj\n{\n    vec3 sdi ; // dS , d , id\n    material mtr;\n};\n\nvec3 normal;\nray r ;\nstar yellow;\n\n\nobj cld = obj(vec3(FAR , 0.,  0.),\n    material(vec3(1.,1.,1.),vec3(.5, 1., 3.), vec3(100.,.5,1.)));\n\n\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); \n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); \n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.; ray r ; r.zoom = 1.;\n    r.o = vec3(0., 6., 10.); r.t = vec3(.5);\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI/2.);\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat torus( in vec3 p, vec3 pos, vec2 rad )\n{\n    p = p - pos ;\n    return length( vec2(length(p.xz)-rad.x,p.y) )-rad.y;\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b,float r) {\n    vec3 d = abs(p-pos) - b;\n    return  length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.) - r ;\n}\n\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    return length(p-pos) - r ;\n\n}\n\n\nobj suop(in obj a, in obj b, float k)\n{\n    obj o;\n    if (a.sdi.x < b.sdi.x) o = a; else o = b;\n    float h = clamp( 0.5+0.5*(b.sdi.x-a.sdi.x)/k, 0.0, 1.0 );\n    o.sdi.x = mix( b.sdi.x, a.sdi.x, h ) - k*h*(1.0-h);\n    return o;\n\n}\n\n\n\nfloat N31(vec3 p){\n\n\tvec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n    p = p*p*(3. - 2.*p);\n\th = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n\n}\n\n"
}
